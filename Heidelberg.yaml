# Stand: 25.10.25
# for ESP32 230V
#
# last change: Rename the software lock to "WB Master", and the hardware lock to "WB Master-hard" so charge control defaults to software locking instead of hardware

substitutions:
  friendly_name: "Wallbox"
  device_name: "wallbox"


esp32:
  board: esp32dev  # set as needed for your board
  framework:
    type: esp-idf

ota:
  - platform: esphome

api:
  encryption:
    key: !secret api_encryption_key


wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

web_server:
  port: 80
  version: 2

logger:
  level: INFO
#  level: DEBUG

button:
  - platform: restart
    name: "Wallbox Restart"

esphome:
  name: ${device_name}
  name_add_mac_suffix: false
  friendly_name: ${friendly_name}
  on_boot:
      priority: -100  # Niedrige Priorität, um nach der Modbus-Initialisierung ausgeführt zu werden
      then:
        - number.set:
            id: heidelberg_charge_current
            value: 6  # Setzt den Ladestrom auf 6 A
        - logger.log: "Set the charge current to 6A on startup"
        - number.set:
            id: heidelberg_failsafe_charge_current
            value: 16  # Setzt den Ladestrom für Kommunikationsfehler auf 6 A
        - logger.log: "Set the failsafe current to 6A on startup"
        - number.set:
            id: heidelberg_powersave
            value: 0  # Turn on powermanagement.
        - logger.log: "Turned on powersaving on the wallbox. Disabling powersaving causes the meter to lose data on a restart"
        - switch.turn_on: heidelberg_master_hard
        - logger.log: "Turned on Master Switch, Wallbox is enabled mechanically"
        - switch.turn_on: heidelberg_master_soft
        - logger.log: "Turned on Soft Switch, Wallbox is enabled logically"


switch:
  - platform: gpio
    name: "WB Master-hard"
    id: heidelberg_master_hard
    pin: GPIO16
    inverted: yes
    entity_category: config
  - platform: template
    name: "WB Master"
    id: heidelberg_master_soft
    lambda: |-
      return (id(heidelberg_softlock).state == 1);
    turn_on_action:
        - number.set:
            id: heidelberg_softlock
            value: 1  # 1 = enable charging.    
    turn_off_action:
        - number.set:
            id: heidelberg_softlock
            value: 0  # 0 = Wallbock locked.
  - platform: template
    name: "WB Powersave aktiv"
    lambda: |-
      return (id(heidelberg_powersave).state == 0);
    turn_on_action:
        - number.set:
            id: heidelberg_powersave
            value: 0  # Turn on powermanagement.    
    turn_off_action:
        - number.set:
            id: heidelberg_powersave
            value: 4  # 4=always on.
    entity_category: config
  - platform: template
    id: "heidelberg_Low_Solar_Input"
    name: "WB Low Solar Input"
    internal: True
    optimistic: True
    on_turn_on:
      - lambda: |-
          id(heidelberg_Low_Solar_Input_Timestamp) = millis();
    on_turn_off:
      - lambda: |-
          id(heidelberg_Low_Solar_Input_Timestamp) = millis();


# UART configuration for RS485
uart:
  id: mod_uart
  tx_pin: GPIO01 # TX pin for RS485 module
  rx_pin: GPIO03 # RX pin for RS485 module
  baud_rate: 19200 # Heidelberg Wallbox default baud rate
  parity: EVEN # Communication parameters: 8E1 (8 data bits, Even parity, 1 stop bit)
  stop_bits: 1


# Modbus configuration
modbus:
  id: mod_bus
  uart_id: mod_uart
  send_wait_time: 200ms # Wait time between Modbus requests


# Modbus Controller for Heidelberg Wallbox
modbus_controller:
  id: heidelberg_wallbox_id01
  address: 1 # Modbus Bus ID (matches S4 DIP switch, e.g., 0001)
  modbus_id: mod_bus
  command_throttle: 100ms # Minimum time between requests
  update_interval: 3s # How often to poll the Wallbox
  on_online:
    then:
    - logger.log: "wallbox back online!"
  on_offline:
    then:
    - logger.log: "wallbox is offline!"


# Sensors (read Wallbox data)
sensor:
  - platform: modbus_controller
    modbus_controller_id: heidelberg_wallbox_id01
    id: heidelberg_softwareversion
    internal: true
    accuracy_decimals: 0
    address: 0x0004 # Register for charging state
    register_type: read
    value_type: U_WORD
    lambda: |-
      return uint32_t(x -156);
  - platform: modbus_controller
    modbus_controller_id: heidelberg_wallbox_id01
    id: heidelberg_ladestatus_num
    internal: False
    address: 0x0005 # Register for charging state
    register_type: read
    value_type: U_WORD
  - platform: modbus_controller
    modbus_controller_id: heidelberg_wallbox_id01
    id: heidelberg_current_l1
    name: "WB Strom L1"
    address: 0x0006 # Register for L1 current (RMS, in 0.1A)
    register_type: read
    value_type: U_WORD
    unit_of_measurement: A
    device_class: current
    accuracy_decimals: 1
    filters:
    - multiply: 0.1 # Convert to Amperes
  - platform: modbus_controller
    modbus_controller_id: heidelberg_wallbox_id01
    id: heidelberg_current_l2
    name: "WB Strom L2"
    address: 0x0007 # Register for L2 current (RMS, in 0.1A)
    register_type: read
    value_type: U_WORD
    unit_of_measurement: A
    device_class: current
    accuracy_decimals: 1
    filters:
    - multiply: 0.1 # Convert to Amperes
  - platform: modbus_controller
    modbus_controller_id: heidelberg_wallbox_id01
    id: heidelberg_current_l3
    name: "WB Strom L3"
    address: 0x0008 # Register for L3 current (RMS, in 0.1A)
    register_type: read
    value_type: U_WORD
    unit_of_measurement: A
    device_class: current
    accuracy_decimals: 1
    filters:
    - multiply: 0.1 # Convert to Amperes
  - platform: modbus_controller
    modbus_controller_id: heidelberg_wallbox_id01
    id: heidelberg_temperature
    name: "WB Temperatur"
    address: 0x0009 # Register for L1 current (RMS, in 0.1A)
    register_type: read
    value_type: S_WORD
    unit_of_measurement: C
    device_class: temperature
    accuracy_decimals: 0
    filters:
    - multiply: 0.1 # Convert to Amperes
  - platform: modbus_controller
    modbus_controller_id: heidelberg_wallbox_id01
    id: heidelberg_voltage_l1
    name: "WB Spannung L1"
    address: 0x000A # Register for L1 voltage (RMS, in V)
    register_type: read
    value_type: U_WORD
    unit_of_measurement: V
    device_class: voltage
    accuracy_decimals: 0
  - platform: modbus_controller
    modbus_controller_id: heidelberg_wallbox_id01
    id: heidelberg_voltage_l2
    name: "WB Spannung L2"
    address: 0x000B # Register for L1 voltage (RMS, in V)
    register_type: read
    value_type: U_WORD
    unit_of_measurement: V
    device_class: voltage
    accuracy_decimals: 0
  - platform: modbus_controller
    modbus_controller_id: heidelberg_wallbox_id01
    id: heidelberg_voltage_l3
    name: "WB Spannung L3"
    address: 0x000C # Register for L1 voltage (RMS, in V)
    register_type: read
    value_type: U_WORD
    unit_of_measurement: V
    device_class: voltage
    accuracy_decimals: 0
  - platform: modbus_controller
    modbus_controller_id: heidelberg_wallbox_id01
    id: heidelberg_power
    name: "WB Leistung"
    address: 0x000e # Register for total power (in VA)
    register_type: read
    value_type: U_WORD
    unit_of_measurement: W
    device_class: power
    accuracy_decimals: 0
  - platform: modbus_controller
    modbus_controller_id: heidelberg_wallbox_id01
    id: heidelberg_energy_powerup
    name: "WB Energie seit Start"
    address: 0x000f  # entspricht Register 30018 (0-basiert!)
    register_type: read
    value_type: U_DWORD  # 32-bit unsigned integer
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total
    accuracy_decimals: 3
    filters:
      - multiply: 0.001  # von Wh → kWh
  - platform: modbus_controller
    modbus_controller_id: heidelberg_wallbox_id01
    id: heidelberg_energy_total
    name: "WB Energie Gesamt"
    address: 0x0011  # entspricht Register 30018 (0-basiert!)
    register_type: read
    value_type: U_DWORD  # 32-bit unsigned integer
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    accuracy_decimals: 3
    filters:
      - multiply: 0.001  # von Wh → kWh
  - platform: template
    id: heidelberg_sw_version
    name: "WB Softwareversion"
    lambda: |-
      return uint32_t(id(heidelberg_softwareversion).state);
    entity_category: diagnostic
  - platform: template
    id: heidelberg_Low_Solar_Input_Duration
    name: "WB Low Solar Input Duration"
    accuracy_decimals: 0
    unit_of_measurement: "s"
    update_interval: 10s 
    entity_category: diagnostic
    lambda: |-
      unsigned long current = millis();
      auto zeit = (current - id(heidelberg_Low_Solar_Input_Timestamp))/1000;
      if (not(id(heidelberg_Low_Solar_Input).state)) { zeit = 0; };
      return zeit;


number:
  - platform: modbus_controller
    modbus_controller_id: heidelberg_wallbox_id01
    id: heidelberg_charge_current
    name: "WB Ladestrom"
    address: 0x0105 # Holding register for max current command
    register_type: holding
    value_type: U_WORD
    min_value: 0 # Minimum current (6A)
    max_value: 16 # Maximum current (16A)
    step: 0.5
    unit_of_measurement: A
    lambda: |-
      return x / 10;
    # Convert to Amperes, map 1-5A to 6A
    # multiply by 10, 1A = 10
    write_lambda: |-
      switch ( int(floor(x)) ) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          return 60;
        default:
          return int(floor(x)) * 10;
      }
#    write_lambda: |-
#      if (x >= 1 && x <= 5) {
#      return 60;
#      } else {
#      return x * 10;
#      }
  - platform: modbus_controller
    modbus_controller_id: heidelberg_wallbox_id01
    id: heidelberg_watchdog
    name: "WB Watchdog Timer"
    internal: yes
    address: 0x0101 # Holding register for max current command
    register_type: holding
    value_type: U_WORD
    min_value: 0 # value in seconds, 0=off
    max_value: 65 # Maximum is 65s
    step: 1
    unit_of_measurement: s
    lambda: |-
      return x / 1000;
    write_lambda: |-
      return x * 1000;
  - platform: modbus_controller
    modbus_controller_id: heidelberg_wallbox_id01
    id: heidelberg_powersave
    name: "WB Powersaving disable"
    internal: True
    address: 0x0102 # Holding register for max current command
    register_type: holding
    value_type: U_WORD
    min_value: 0 # value in seconds, 0=off
    max_value: 4 # Maximum is 65s
    step: 4
    # only bit 2 is relevant, either 0 or 4, 4=disable
    entity_category: config
  - platform: modbus_controller
    modbus_controller_id: heidelberg_wallbox_id01
    id: heidelberg_softlock
    name: "WB Softswitch"
    internal: True
    address: 0x0103 # Holding register for max current command
    register_type: holding
    value_type: U_WORD
    min_value: 0 # value in seconds, 0=off
    max_value: 1 # Maximum is 65s
    step: 1
    # 1=enabled, 0=disabled
    entity_category: config
  - platform: modbus_controller
    modbus_controller_id: heidelberg_wallbox_id01
    id: heidelberg_failsafe_charge_current
    name: "WB Failsafe Charge Current"
    address: 0x0106 # Holding register for max current command
    register_type: holding
    value_type: U_WORD
    min_value: 0 # Minimum current (6A), 0=off
    max_value: 16 # Maximum current (16A) remember we have 3 phases, 16A=11kW
    step: 1
    unit_of_measurement: A
    # read: divide by 10 because 10 -> 1A
    lambda: |-
      return x / 10;
    # write: Convert to Amperes, 1-5A is disallowed
    # multiply by 10, because 1A -> 10
    write_lambda: |-
      if (x >= 1 && x <= 5) {
      return 60;
      } else {
      return x * 10;
      }
    entity_category: config
  - platform: template
    id: heidelberg_power_subtract
    name: "Heidelberg_Hausverbrauch"
    optimistic: True
    restore_value: True
    min_value: 0
    max_value: 10000
    step: 100
    entity_category: config
  - platform: template
    id: heidelberg_power_avail
    name: "Heidelberg Leistung_PV"
    optimistic: True
    min_value: 0
    max_value: 11000
    step: 1
    on_value: 
      then:
        - if:
            condition:
              lambda: 'return x < 4140;'
            then:
              - switch.turn_on: heidelberg_Low_Solar_Input
            else:
              - switch.turn_off: heidelberg_Low_Solar_Input
        - lambda: |-
            // calculate amperage from Solar power and house consumption
            float ampere = (x - id(heidelberg_power_subtract).state) / 230 /3;
            ampere = floor(ampere);
              unsigned long current = millis();
            // if current is under 6A, keep charging for 5 minutes, then turn charging off
            if (ampere <6 and id(heidelberg_Low_Solar_Input).state &&
                (id(heidelberg_Low_Solar_Input_Duration).state > 300)) {
              ampere = 0;
            }
            // transfer ampere to Modbus Register 
            auto call = id(heidelberg_charge_current).make_call();
            call.set_value( ampere );
            call.perform();
            // (id(heidelberg_charge_current).publish_state(ampere));


text_sensor:
  - platform: template
    id: heidelberg_Ladestatus
    name: "WB Ladestatus"
    lambda: |-
      auto value = id(heidelberg_ladestatus_num).state;
      switch ((uint16_t)value) {
      case 2: return std::string("Frei");
      case 3: return std::string("Frei");
      case 4: return std::string("Gesperrt");
      case 5: return std::string("Bereit");
      case 6: return std::string("nein-6");
      case 7: return std::string("Laedt");
      case 8: return std::string("Reduziert");
      case 9: return std::string("Fehler-Isolation");
      case 10: return std::string("Gesperrt-Soft");
      default: return std::string("Fehler");
      }
  - platform: template
    id: heidelberg_Ladestatus_ISO
    name: "WB Ladestatus-ISO"
    lambda: |-
      auto value = id(heidelberg_ladestatus_num).state;
      switch ((uint16_t)value) {
      case 2: return std::string("A1");
      case 3: return std::string("A2");
      case 4: return std::string("B1");
      case 5: return std::string("B2");
      case 6: return std::string("C1");
      case 7: return std::string("C2");
      case 8: return std::string("derating");
      case 9: return std::string("E");
      case 10: return std::string("E");
      case 11: return std::string("11");
      default: return std::string("Fehler");
      }
    entity_category: diagnostic

binary_sensor:
  - platform: template
    id: heidelberg_Ladekabel
    name: "WB Ladekabel"
    lambda: |-
      auto value = id(heidelberg_ladestatus_num).state;
      switch ((uint16_t)value) {
      case 2: return false;
      case 3: return false;
      case 4: return true;
      case 5: return true;
      case 6: return true;
      case 7: return true;
      case 8: return true;
      case 9: return {};
      case 10: return {};
      default: return {};
      }
globals:
  - id: heidelberg_Low_Solar_Input_Timestamp
    type: unsigned long
    restore_value: no
    initial_value: '0'
